# hiho第012周:刷油漆

* **题目描述**

上回说到,小Ho有着一棵灰常好玩的树玩具!这棵树玩具是由N个小球和N-1根木棍拼凑而成,这N个小球都被小Ho标上了不同的数字,并且这些数字都是处于1..N的范围之内,每根木棍都连接着两个不同的小球,并且保证任意两个小球间都不存在两条不同的路径可以互相到达。没错,这次说的还是这棵树玩具的故事!

小Ho的树玩具的质量似乎不是很好,短短玩了几个星期,便掉漆了!

“简直是一场噩梦!”小Ho拿着树玩具眼含热泪道。

“这有什么好忧伤的,自己买点油漆刷一刷不就行了?”小Hi表示不能理解。

“还可以这样?”小Ho顿时兴高采烈了起来,立马跑出去买回来了油漆,但是小Ho身上的钱却不够——于是他只买回了有限的油漆,这些油漆最多能给M个结点涂上颜色,这就意味着小Ho不能够将他心爱的树玩具中的每一个结点都涂上油漆!

小Ho低头思索了半天——他既不想只选一部分结点补漆,也不想找小Hi借钱,但是很快,他想出了一个非常棒的主意:将包含1号结点的一部分连通的结点进行涂漆(这里的连通指的是这一些涂漆的结点可以互相到达并且不会经过没有涂漆的结点),然后将剩下的结点拆掉!

那么究竟选择哪些结点进行涂漆呢?小Ho想了想给每个结点都评上了分——他希望最后留下来,也就是涂漆了的那些结点的评分之和可以尽可能的高!

那么,小Ho该如何做呢?

> * **提示一:树上的动态规划?其实老早就接触过了吧!**

“是啊,我该怎么做呢?”小Ho想道,但是如果能很快就自己想出来那也就不是小Ho了,于是小Ho还是老老实实去请教了小Hi。

小Hi听了小Ho的问题,道:“这个问题不是很简单么?来,我们再重复一下之前的步骤——先抽象你的问题。”

“好的!应该是这样的——f(t, m)表示,在以t为根的一棵树中,选出包含根节点t的m个连通的结点,能够获得的最高的评分,然后我们的答案就是f(1, M)!”身经百战的小Ho也是只需要一下点拨,立马就答了出来。

“那么你应该如何分解这个问题为子问题呢?”小Hi继续问道。

“一般的思路会是这样子的,首先我要包含根节点,然后与根节点连通的结点最开始便是根节点的子结点,而所有选择的结点都要互相连通的话,那么如果选择某一棵子树中的结点的话就势必也需要选择这棵子树的根节点——所以就变成了一个规模小一些的子问题。比如在求解f(t, m)的时候,我先枚举t的第一个子结点t1中选出的结点数m1,然后枚举t的第二个子结点t2中选出的结点数m2……一直到t的最后一个子结点tk中选出的结点数mk,这样就有f(t, m) = max{f(t1, m1) + f(t2, m2) + …… + f(tk, mk)} + v(t),并且需要保证m1+m2+...+mk+1=m。”小Ho答道。

小Hi摇了摇头:“但是你不觉得这样这个算法就是指数级了么?m1...mk可能有的方案数可是非常多的呢!”

“唔……我知道了,这里不是和无限背包问题很像么?我可以不用单独的求解每一个f(t, m)而是针对于每一个t,同时求解它的f(t, 0..M),这样的话,我就可以把m视作背包容量,把每个子结点`t_child`都视作一件单位重量为1的物品,但是和背包问题不同的是,这件物品的总价值并不是单位价值乘以总重量,而是重量为m_child的该物品的价值为`f(t_child, m_child)`,这样我就可以像无限背包问题一样,用这样的方法来进行求解!

![](http://media.hihocoder.com//problem_images/20140920/14112039442549.png)

“没错呢!但是你这样的话不会导致`f(t_child, m_child)`计算很多次么?”小Hi也是故意要考一考小Ho。

“这你就小瞧我了,我学了这么久动态规划难道还不知道我可以以后序遍历的方式访问这棵树,这样当计算f(t, 0..M)的时候,我就已经计算出了所有的`f(t_child, m_child)`的值,如果我将这些值储存在数组中的话,我就不需要再递归计算了!”小Ho信心满满的答道。

“真聪明!那你还不快去写程序?你的油漆都要干了哦!”

* **输入输出**

> * **输入**

每个测试点(输入文件)有且仅有一组测试数据。

每组测试数据的第一行为两个整数N、M,意义如前文所述。

每组测试数据的第二行为N个整数,其中第i个整数Vi表示标号为i的结点的评分

每组测试数据的第3~N+1行,每行分别描述一根木棍,其中第i+1行为两个整数Ai,Bi,表示第i根木棍连接的两个小球的编号。

对于100%的数据,满足N<=10^2,1<=Ai<=N, 1<=Bi<=N, 1<=Vi<=10^3, 1<=M<=N

小Hi的Tip:那些用数组存储树边的记得要开两倍大小哦!

> * **输出**

对于每组测试数据,输出一个整数Ans,表示使得涂漆结点的评分之和最高可能是多少。

样例输入

```sh
10 4
370 328 750 930 604 732 159 167 945 210 
1 2
2 3
1 4
1 5
4 6
4 7
4 8
6 9
5 10
```

样例输出

```sh
2977
```

* **解题代码**
	
```c
#include <cstdio>
#define MAX(x,y) ((x)>(y)?(x):(y))

int f[101][101] = {}, header[101] = {};
int n, m;
struct {
    int next, to;
} tree_node[100];

void dfs(int);

int main(int argc, char* argv[]) {
    int i, from, to;
    scanf("%d%d", &n, &m);
    for(i = 1; i <= n; i++)
        scanf("%d", &f[i][1]);
    for(i = 1; i < n ; i++) {
        scanf("%d%d", &from, &to);
        tree_node[i].to = to;
        tree_node[i].next = header[from];
        header[from] = i;
    }
    dfs(1);
    printf("%d\n", f[1][m]);
    return 0;
}

void dfs(int t) {
    int p = header[t];
    int i, j;
    while(p) {
        dfs(tree_node[p].to);
        p = tree_node[p].next;
    }

    p = header[t];
    while(p) {
        for(j = m; j > 1; j--)
            for(i = 1; i < j; i++)
                f[t][j] = MAX(f[t][j], f[t][j-i] + f[tree_node[p].to][i]);
        p = tree_node[p].next;
    }
}
```
